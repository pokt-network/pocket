# ICS-23 Vector Commitments <!-- omit in toc -->

- [Overview](#overview)
- [Implementation](#implementation)
  - [Custom SMT `ProofSpec`](#custom-smt-proofspec)
  - [Converting `SparseMerkleProof` to `CommitmentProof`](#converting-sparsemerkleproof-to-commitmentproof)
  - [Proof Verification](#proof-verification)

## Overview

[ICS-23][ics23] defines the types and functions needed to verify membership of a key-value pair in a `CommitmentState`. As the Pocket IBC implementation uses the [SMT][smt] for its provable stores this is what is referred to as the `CommitmentState` object. Cosmos has a library `cosmos/ics23` which is already SDK agnostic and defines many of the types necessary for ICS-23. This library was able to be used _mostly_ out of the box, with some minor adjustments detailed below.

## Implementation

The benefit of using `cosmos/ics23` over implementing similar types ourselves is twofold:

1. It is already SDK agnostic, so can be used by Pocket (a non-cosmos chain) without any issues.
2. The functions defined for proof verification are separate from the tree structures themselves
   - This means we do not need to interact with an SMT instance in order to verify proofs.

However, there were some changes made specifically for Pocket's implementation of ICS-23.

### Custom SMT `ProofSpec`

The `ProofSpec` type in `cosmos/ics23` is used to define the steps needed to verify a proof, what hashing functions should be used, any node prefixes, etc. This is then passed into the verification functions in order to verify a proof, instead of having to interact with the tree itself. This is useful as proofs must be verified on a light-client and as such being able to verify a proof without creating a tree is much more memory efficient.

As the SMT used by Pocket Network only stores hashed values by default, the IBC stores use the `WithValueHasher(nil)` option which stores the raw bytes of the values in the tree. As such the following `ProofSpec` was created:

```go
smtSpec *ics23.ProofSpec = &ics23.ProofSpec{
	LeafSpec: &ics23.LeafOp{
		Hash:         ics23.HashOp_SHA256,
		PrehashKey:   ics23.HashOp_SHA256,
		PrehashValue: ics23.HashOp_NO_HASH,
		Length:       ics23.LengthOp_NO_PREFIX,
        Prefix:       []byte{0},
	},
	InnerSpec: &ics23.InnerSpec{
		ChildOrder:      []int32{0, 1},
		ChildSize:       32,
		MinPrefixLength: 1,
		MaxPrefixLength: 1,
        EmptyChild:      make([]byte, 32),
		Hash:            ics23.HashOp_SHA256,
	},
	MaxDepth:                   256,
	PrehashKeyBeforeComparison: true,
}
```

The main change from the `cosmos/ics23` `SmtSpec` object is that the `PrehashValue` field is set to not hash values prior to hashing the key-value pair.

### Converting `SparseMerkleProof` to `CommitmentProof`

In order to convert the proofs generated by the SMT into a serialisable proof used by `cosmos/ics23`, the `SideNodes` field of the `SparseMerkleProof` must be converted into a list of `InnerOp` types which define the order of the hashes. The order of the hashes is important as depending on whether the next hash is the left or right neighbour of the current hash, they will be hashed in a different order, ultimately creating a different root hash. This conversion allows the verification to produce the same root hash as the SMT would have produced when verifying the proof.

As `SparseMerkleProof` objects represent both inclusion and exclusion proofs as defined in the [JMT whitepaper][jmt] the conversion step will convert the SMT proof into either a `ExistenceProof` or `ExclusionProof` as defined in `cosmos/ics23`.

### Proof Verification

When verifying membership of an element the logic is as follows:

1. Use the key-value pair to generate a leaf hash
2. Hash the leaf with the `SideNodes` found in the `path` field of the `ExistenceProof` to generate the root hash
3. Compare the root hash with the one provided

For non-membership the logic is as follows:

1. If the `ActualValueHash` field in the `ExclusionProof` is the SMT's placeholder value, then use the placeholder value as the leaf node hash and follow steps 3-4
2. If the `ActualValueHash` field is not the placeholder value, then use the `ActualPath` and `ActualValueHash` fields to generate the leaf node hash - do not hash these values before hashing the node as they are populated from the SMT proof's `NonMembershipLeafData` field and thus are already hashed
3. Hash the leaf node hash with the `SideNodes` found in the `Path` field of the `ExclusionProof` to generate the root hash
4. Compare the root hash with the one provided

The full implementation of this logic can be found [here](../store/proofs_ics23.go) as well as in the `cosmos/ics23` [library](https://github.com/h5law/ics23/blob/56d948cafb83ded78dc4b9de3c8b04582734851a/go/proof.go#L171).

[ics23]: https://github.com/cosmos/ibc/blob/main/spec/core/ics-023-vector-commitments/README.md
[smt]: https://github.com/pokt-network/smt
[jmt]: https://developers.diem.com/papers/jellyfish-merkle-tree/2021-01-14.pdf
