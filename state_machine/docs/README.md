# State Machine Module <!-- omit in toc -->

> ⚠️ Work in progress ⚠️ - At the time of writing this document, the architecture is still being defined.
>
> This is pretty much a POC at the moment.

This document outlines the purpose of this module, its components and how they all interact with the other modules.

## Contents <!-- omit in toc -->
- [Overview](#overview)
- [Code Structure](#code-structure)
- [High Level Architecture](#high-level-architecture)
  - [FSM primer](#fsm-primer)
- [Current State Machine Definition](#current-state-machine-definition)

## Overview

The `StateMachine` module implements a FSM (Finite State Machine) that is responsible for managing the node lifecycle since its internal behaviour can be different depending on certain conditions that are used to determine the current state.

In a nutshell: The FSM guarantees that the node is always in one specific state and verifies state transition (i.e. edges) to/from valid states (i.e. vertices).

## Code Structure

```bash
├── docs
│   ├── CHANGELOG.md              # Changelog
│   ├── README.md                 # You are here
│   └── state-machine.diagram.md  # State machine diagram (generated by visualizer/main.go)
├── fsm.go                        # Finite State Machine definition (events, states, transitions)
├── module.go                     # Implementation of the StateMachine module
└── visualizer
    └── main.go                   # State machine diagram generator
```

## High Level Architecture

High-level implementation details:

- The [github.com/looplab/fsm](https://github.com/looplab/fsm) library is used to implement the FSM
- Pocket builds a wrapper around `looplab/fsm` to integrate with the other modules
- The `StateMachineModule` can be accessed via the `bus` from any other `IntegratableModule`
- State machine transitions emit `StateMachineTransitionEvent` events that subscribed pocket modules can listen to
- The `node` has a central [event handler](../../shared/node.go) for events that fan-out event handling to the relevant modules during state transitions

### FSM primer

The FSM has a declarative definition of an initial state and a set of transitions that have an `Event`, `Source` states and a single `Destination` state.

These are the main building blocks:

- **Event**: An event is a string that represents an action that can trigger a transition. For example, the event `start` can be used to trigger a transition from the `stopped` state to the `starting` state.
- **State**: A state is a string that represents a state that the FSM can be in. For example, the state `stopped` can be used to represent a state where the node is not running.
- **Callback**: A callback is a function that is called when a transition occurs. For example, a callback can be used to log the transition or to perform some other action. Various types of callbacks essentially drive behaviour **WHEN** they are called and help build more complex behaviours like transition cancelling, etc. See the core FSM library documentation for more details.

## Current State Machine Definition

A diagram of the current state machine definition can be found [here](state-machine.diagram.md)
If you make any changes to it, you can re-generate it via:

```bash
make generate_node_state_machine_diagram
```

<!-- GITHUB_WIKI: state_machine/README -->
