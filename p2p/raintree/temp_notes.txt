# Assumptions

## Assumption 1: Each node has a unique addresses that can be used for lexicographical sorting.

## Assumption 2: Each participating peer / node / actor has a full view of the network (i.e. list of all unique addresses is available to each node)

# Definitions

## Definition 1: Layer: the inverse of a tree height (max at the root and 0 at a leaf)

## Definition 2: Max # of layers: tree height

## Definition 3: Global Address Book: list of all unique addresses in the network

## Definition 4: Partial Address Book: partial list of all unique addresses nodes in the network (either due to algorithm or due to lack of information)

# Structure

## RainTree: A ternary tree where one of the children of each non-leaf node is a copy of itself with a different subtree

## AddrBook: A sorted list of unique addresses that a node / peer is operating on at a given point in time in the algorithm

# Params

## Let X be the % used to calculate the index of the 1st message sent by a node in `AddrBook` defined above (e.g. X = 1/3 when AddrBook has 9 nodes implies the 3rd node in the sorted list)

## Let Y be the % used to calculate the index of the 2nd message sent by a node in `AddrBook` defined above (e.g. Y = 2/3 when AddrBook has 9 nodes implies the 6th node in the sorted list)

## Let Z be the % by which the `AddrBook` defined above is shrunk with each message propagation (e.g. Z = 2/3 when AddrBook has 9 nodes implies a new AddrBook including nodes 1 through 6)

# Questions to answer:

# Q: What should the stopping condition be aside from cheap log3(N)?

# Q: Why does log3 base achieve the desired height?

# Q: Do X & Y need to be constants?

# Q: Can X & Y be random but in some range?

# Q: Does Y need to equal Z?

# Analyze:

# - Run simulation over different N and check if log3(N) always achieves the desired height

# - Increase # simulations and check if the average number of messages different

# TODO:

# - Redundancy & failure
