// TODO(olshansky): This encapsulates hotstuff types, hotstuff messages and hotstuff specific crypto primitives. Consider if it's worth splitting into smaller files.

syntax = "proto3";

package consensus;

option go_package = "/types/";

import "block_cons_temp.proto";

enum HotstuffStep {
    HOTSTUFF_STEP_UNKNOWN = 0;
    HOTSTUFF_STEP_NEWROUND = 1;
    HOTSTUFF_STEP_PREPARE = 2;
    HOTSTUFF_STEP_PRECOMMIT = 3;
    HOTSTUFF_STEP_COMMIT = 4;
    HOTSTUFF_STEP_DECIDE = 5;
}

enum HotstuffMessageType {
    HOTSTUFF_MESSAGE_UNKNOWN = 0;
    HOTSTUFF_MESAGE_PROPOSE = 1;
    HOTSTUFF_MESSAGE_VOTE = 2;
}

// TODO(research): Until we figure out which library to use for threshold
// signatures, mimick the behaviour by looping over individual signatures.
message PartialSignature {
    bytes signature = 1;
    string address = 2;
}

message ThresholdSignature {
    repeated PartialSignature signatures = 1;
}

message QuorumCertificate {
    uint64 height = 1;
    uint64 round = 2;
    HotstuffStep step = 3;
    BlockConsensusTemp block = 4;
    ThresholdSignature signature = 5;
}

message HotstuffMessage  {
    HotstuffMessageType type = 1;
    HotstuffStep step = 2;
    uint64 height = 3;
    uint64 round = 4;
    BlockConsensusTemp block = 5;

    oneof justification {
        QuorumCertificate quorum_certificate = 6;  // From LEADER -> REPLICA for PROPOSE messages; one of {HighQC, TimeoutQC, CommitQC}
        PartialSignature partial_signature = 7; // From REPLICA -> LEADER for VOTE messages; signature over <height, round, block>
    }
}